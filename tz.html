<!DOCTYPE html>
<html class="body_base">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <link rel="stylesheet" type="text/css" href="samples.css">

<body>

  <h1 class="title">WebRTC API</h1>


    <h2>Содержание:</h2>
    <ul class = toc>
      <li><a href="tz.html#one">Введение</a>
      </li>
      <li><a href="tz.html#two">Понятия и использование WebRTC </a>
      </li>
      <li>
        <a href="tz.html#three">Протоколы WebRTC</a>
        <ol>
          <li>
            <a href="tz.html#three_one"> ICE </a>
          </li>
          <li>
            <a href="tz.html#three_two"> STUN </a>
          </li>
          <li>
            <a href="tz.html#three_three"> NAT </a>
          </li>
          <li>
            <a href="tz.html#three_four"> TURN </a>
          </li>
          <li>
            <a href="tz.html#three_five"> SDP </a>
          </li>
        </ol>
      </li>

      <li><a href="tz.html#four">Сигнализированные и видео вызов</a>
        <ul>
          <li>
            <a href="tz.html#four_one">Сервер сигнализации</a>
          </li>
        </ul>
      </li>
      <li><a href="tz.html#five">Жизнь WebRTC-сессии</a>
        <ol>
          <li>
            <a href="tz.html#five_one">
              Установка соединения
            </a>
          </li>
          <li>
            <a href="tz.html#five_two">
              Процесс Сигнализации
            </a>
          </li>
          <li>
            <a href="tz.html#five_three">
              Перезапуск сессии ICE агент
            </a>
          </li>
        </ol>
      </li>
    </ul>


  <h2 id="one">Введение</h2>
  <p>
    WebRTC (Web Real-Time Communications) - это технология,
    которая позволяет Web-приложениям и сайтам захватывать и
    выборочно передавать аудио и/или видео медиа-потоки, а также обмениваться
    произвольными данными между браузерами, без обязательного использования посредников.
    Набор стандартов, которые включает в себя технология WebRTC, позволяет обмениваться
    данными и проводить пиринговые телеконференции, без необходимости пользователю
    устанавливать плагины или любое другое стороннее программное обеспечение.
  </p>

  <P>
    WebRTC состоит из нескольких взаимосвязанных программных интерфейсов (API) и
    протоколов, которые работают вместе. Документация, которую вы здесь найдёте, поможет
    вам понять основы WebRTC, как настроить и использовать соединение для передачи данных
    и медиа-потока, и многое другое.


  </p>


  <h2 id="two">Понятия и использование WebRTC </h2>
  <p>
    WebRTC является многоцелевым и вместе с <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API">Media Capture and Streams API</a>,
    предоставляют мощные мультимедийные
    возможности для Web, включая поддержку аудио и видео конференций, обмен файлами, захват экрана, управление
    идентификацией и взаимодействие с устаревшими телефонными системами, включая поддержку передачи сигналов тонового
    набора <a href="https://developer.mozilla.org/en-US/docs/Glossary/DTMF">DTMF</a> . Соединения между узлами могут
    создаваться без использования специальных драйверов или плагинов,
    и часто без промежуточных сервисов.
  </p>
  <p>
    Соединение между двумя узлами представлено как объект интерфейса <a
      href="https://developer.mozilla.org/ru/docs/Web/API/RTCPeerConnection">RTCPeerConnection</a>. Как только
    соединение
    установлено и открыто, используя объект RTCPeerConnection, медиапотоки <a
      href="https://developer.mozilla.org/ru/docs/Web/API/MediaStream">MediaStreams</a> и/или каналы данных
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel">RTCDataChannel</a> могут быть добавлены в
    соединение.
  </p>
  <p>
    Медиа потоки могут состоять из любого количества треков (дорожек) медиаинформации. Эти треки, представлены объектами
    интерфейса <a href="https://developer.mozilla.org/ru/docs/Web/API/MediaStreamTrack">MediaStreamTrack</a> , и могут
    содержать один или несколько типов медиаданных,
    включая аудио, видео, текст
    (такие как субтитры или название глав). Большинство потоков состоят, как минимум, только из одного аудио трека
    (одной аудио дорожки), или видео дорожки, и могут быть отправлены и получены, как потоки (медиаданные в настоящим
    времени) или сохранены в файл.
  </p>

  <p>
    Так же, можно использовать соединение между двумя узлами для обмена произвольными данными, используя объект
    интерфейса <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel">RTCDataChannel</a>, что может
    быть использовано для передачи служебной информации, биржевых данных ,
    пакетов игровых статусов, передача файлов или закрытых каналов передачи данных.
  </p>


  <h2 id="three">Протоколы WebRTC </h2>
  <h3 id="three_one"> ICE</h3>
  <p>
    <a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">Interactive Connectivity
      Establishment (ICE)</a>
    Представляет собой каркас, позволяющий вашему веб-браузеру соединяться с узлами. Есть много причин, почему прямое
    соединение от узла A к узлу B просто не будет работать. Оно должно обойти межсетевые экраны, которые будут
    препятствовать открытию соединений, дать вам уникальный адрес, если, как в большинстве ситуаций, ваше устройство не
    имеет публичного IP-адреса, и передавать данные через сервер, если ваш маршрутизатор не позволяет вам напрямую
    соединяться с узлами.
  </p>

  <h3 id="three_two"> STUN</h3>
  <p>
    <a href="http://en.wikipedia.org/wiki/STUN">Session Traversal Utilities for NAT (STUN)</a> (акроним в акрониме) это
    протокол для нахождения и определения вашего
    публичного адреса и любых ограничений в вашем маршрутизаторе, которые препятствуют прямому соединению с узлом.

    Клиент отправит запрос к STUN серверу в интернете, который ответит публичным адресом клиента и, доступен ли, или
    нет, клиент за NAT маршрутизатором.
  </p>

  <h3 id="three_three"> NAT</h3>
  <p>
    <a href="http://en.wikipedia.org/wiki/NAT">Network Address Translation (NAT)</a> используется для того, чтобы дать
    вашему устройству публичный IP-адрес.
    Маршрутизатор имеет публичный IP-адрес, а каждое устройство, подключённое к маршрутизатору имеет частный IP-адрес.
    Запросы будут транслированы от частного IP-адреса устройства к публичному IP-адресу маршрутизатора (с уникальным
    портом). Таким образом вам не нужен уникальный IP-адрес для каждого устройства, тем не менее, оно может быть
    обнаружено в интернете.

    Некоторые маршрутизаторы имеют ограничения на то, кто может подключаться к устройствам в сети. Это может означать,
    что даже если мы имеем публичный IP-адрес, найденный STUN сервером, никто не может создать соединение. В этой
    ситуации нам нужно обратиться к TURN.
  </p>
  <h3 id="three_four"> TURN</h3>
  <p>
    Некоторые маршрутизаторы, использующие NAT применяют ограничение, называемое "Симметричный NAT" (Symmetric NAT). Это
    означает, что маршрутизатор будет принимать соединения только от узлов, к которым вы ранее подключились.
  </p>

  <p>
    <a href="http://en.wikipedia.org/wiki/TURN">Traversal Using Relays around NAT (TURN)</a> предназначен для обхода
    ограничения "Симметричный NAT" путём открытия
    соединения с TURN сервером и ретрансляции всей информации через этот сервер. Вы создадите соединение с TURN сервером
    и сообщите всем узлам слать пакеты этому серверу, которые затем будут переправлены вам. Очевидно, что они приходят с
    некоторыми накладными расходами, поэтому это используется, только если нет других альтернатив.
  </p>
  <h3 id="three_five"> SDP</h3>
  <p>
    <a href="http://en.wikipedia.org/wiki/Session_Description_Protocol">Session Description Protocol (SDP)</a> - это
    стандарт для описания мультимедийного контента соединения, как например:
    разрешение, форматы, кодеки, шифрование и т.д. Так, чтобы оба узла могли понять друг друга, после того как данные
    начнут передаваться. Это, в сущности, метаданные, описывающие содержимое, а не медиа контент сам по себе.
  </p>
  <h2 id="four">Сигнализированные и видео вызов</h2>
  <p>
    WebRTC позволяет обмениваться медиаданными между двумя устройствами напрямую (peer-to-peer) в режиме реального
    времени. Соединение устанавливается путём обнаружения и согласования, называемым сигнализацией (signaling).

    WebRTC это технология прямого обмена аудио-, видео- и другими данными в режиме реального времени с одним ключевым
    условием. Процесс обнаружения и согласования медиаформатов должен происходить так чтобы два устройства, подключённые
    к разным сетям, могли локализовать друг друга, как обсуждалось здесь. Этот процесс назван сигнализацией и
    подразумевает, что оба устройства подключаются к третьему, обоюдно согласованному серверу. Через третью сторону
    устройства определяют адреса друг друга и обмениваются согласующими сообщениями.

  </p>
  <h3 id="four_one">Сервер сигнализации</h3>
  <p>
    Для установление WebRTC-соединения между двумя устройствами необходим сервер сигнализации, чтобы определить, как
    соединять эти устройства через Интернет. Сервер сигнализации выступает посредником между пирами, позволяя им найти
    адреса друг друга и установить соединение, и предельно минимизирует риск утечки информации, которая может оказаться
    личной.
  </p>

  <p>
    Во-первых, нужен сам сервер сигнализации. Спецификация WebRTC не определяет, что используется для
    передачи сигнальной информации. Вы можете использовать что вам нравится, от <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket</a> до <a
      href="https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> и почтовых
    голубей, чтобы передать сигнальную информацию между пирами.
  </p>

  <p>
    Важно, что серверу не нужно понимать или интерпретировать сигнальные данные. Хотя они в формате SDP, это не имеет
    особого значения: содержание сообщений, проходящих через сигнальный сервер - по сути, чёрный ящик. Значение имеет
    лишь то, что когда подсистема ICE (en-US) даёт команду передать данные другому пиру, вы просто это делаете, а уже
    пир знает, как получить эту информацию и доставить её на свою подсистему ICE. Все что нужно - передавать сообщения
    туда и обратно. Содержание совершенно не важно для сигнального сервера.
  </p>

  <h2 id="five">Жизнь WebRTC-сессии</h2>
  <h3 id="five_one">Установка соединения</h3>
  <p>
    Интернет большой. Умные люди, несколько лет назад, заметив то, насколько он велик, каким большим он
    может стать и то как быстро растёт, а также ограничения 32-битной системы адресации протокола IP, и поняли, что
    нужно начать что-то делать, чтобы создать новую 64-битную систему адресации. Но в какой-то момент они так же пришли
    к выводу, что переход на новую систему займёт больше времени, чем продержатся 32-разрядные адреса. Затем другие
    умные люди придумали способ, позволяющий нескольким компьютерам использовать один и тот же 32-итный IP-адрес.
    Network Address Translation <a href="https://developer.mozilla.org/en-US/docs/Glossary/NAT">NAT</a> - это стандарт,
    который поддерживает разделение адреса путём маршрутизации
    входящих и исходящих пакетов данных в и из локальной сети (LAN), которые разделяют единственный WAN (глобальный)
    адрес.
  </p>
  <p>
    Проблемой для пользователя является то, что каждый отдельный компьютер в сети Интернет не обязан иметь уникальный
    IP-адрес, и по сути, IP-адрес устройства может измениться не только тогда, когда оно перемещается из одной сети в
    другую, но и если их сетевой адрес был изменён <a
      href="https://developer.mozilla.org/en-US/docs/Glossary/NAT">NAT</a> и/или <a
      href="https://ru.wikipedia.org/wiki/DHCP">DHCP</a>. Для разработчиков, пытающихся строить
    одноранговые сети, эта ситуация является хорошей головоломкой: без уникального идентификатора для каждого
    устройства, нет возможности моментально автоматически выяснить то, как подключиться к конкретному устройству в
    Интернет. Если вызнаете, с кем вы хотите поговорить, вам не обязательно знать, какой адрес у вашего собеседника.
  </p>
  <h3 if="five_two">Процесс Сигнализации</h3>
  <P>
    Сигнализация - это процесс передачи управляющей информации между двумя устройствами для определения протоколов
    связи, каналов, кодирования и формата медиа-данных, методов передачи данных, а также информации, необходимой для
    маршрутизации. Наиболее важная вещь, о которой нужно знать о процессе сигнализации для WebRTC - этот процесс не
    определён в спецификации.
  </P>
  <P>
    Вы можете задаться вопросом, почему нечто основоположное для процесса установки WebRTC-соединения вынесено из
    спецификации? Ответ прост: потому как два устройства не могут контактировать друг с другом, и спецификация не может
    предусмотреть все возможные способы использования WebRTC, также это приобретает ещё больший смысл с точки зрения
    предоставления разработчику возможности выбора наиболее подходящей сетевой технологии и протоколов передачи
    сообщений.
  </P>
  <P>
    Для обмена сигнальной информацией, вы можете выбрать отправку JSON-объектов через WebSocket-соединение, можете
    использовать протокол XMPP/SIP через соответствующий канал, так же можете использовать <a
      href="https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> через <a
      href="https://developer.mozilla.org/ru/docs/Glossary/https">HTTPS</a> с
    техникой пуллинга (<a href="https://developer.mozilla.org/ru/docs/Glossary/https">HTTPS</a> with polling), или же
    другие комбинации технологий, которые вам могут прийти в голову. Вы
    даже можете использовать электронную почту в качестве сигнального канала.
  </P>
  <P>
    Стоит также отметить, что сигнальный канал может вообще находиться вне компьютерной сети. Один узел может выпустить
    объект данных, который затем может быть распечатан на принтере, физически перемещается (пешком или голубиной почтой)
    до другого устройства, данные вводятся в устройство, ответ устройства затем возвращается обратно, так же пешком, и
    так далее, пока WebRTC-соединение между узлами открыто. В этом случае, будет очень высокая латентность, но этот
    сценарий возможен.
  <h4>Обмен информации во время процесса сигнализации</h4>
  </P>

  <P>
    Существует три основных типа информации, которой нужно обмениваться во время процесса сигнализации:
  </P>
  <P>
  <ul>
    <li>
      Управляющие сообщения, используемые для настройки, открытия и закрытия каналов коммуникации, а также для обработки
      ошибок
    </li>
    <li>
      Информация, необходимая для того, чтобы настроить соединение: информация об IP-адресе и порте необходима узлам,
      чтобы они могли разговаривать друг с другом.
    </li>
    <li>
      Необходимо согласовать медиа-потоки: какие могут использоваться между узлами кодеки и форматы медиа-данных? Все
      это необходимо согласовать до того, как будет установлена WebRTC-сессия.
    </li>
  </ul>
  </P>

  <P>
    Только после успешного завершения процесса сигнализации, может быть возможен процесс открытия WebRTC-соединения
    между узлами.


  </P>
  <P>
    Стоит также отметить, что сигнальному серверу не нужно понимать данные, которыми через него обмениваются между собой
    два узла, или что-нибудь с ними делать. Сигнальный сервер, по существу, является ретранслятором - общей точкой,
    которую знают обе стороны могут к ней подключиться чтобы передавать данные через неё. Сервер не должен реагировать
    на передаваемую информацию ни коим образом.


  </P>
  <h4>Процесс сигнализации </h4>
  <P>
    Существует последовательность действий, которую нужно выполнить, чтобы стало возможным начало WebRTC-сессии:
  </P>

  <P>
  <ol>
    <li>
      Каждый узел создаёт объект <a
        href='https://developer.mozilla.org/ru/docs/Web/API/RTCPeerConnection'>RTCPeerConnection</a>, представляющий
      собой WebRTC-сессию и сохраняющийся до её завершения.
    </li>

    <li>
      Каждый узел устанавливает обработчик события <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event">icecandidate</a>,которая
      занимается отправкой этих кандидатов в другую сторону по каналу сигнализации.
    </li>

    <li>
      Каждый узел устанавливает обработчик события <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/track_event">addstream</a>, которое
      срабатывает когда начинает приходить поток данных
      от удалённого узла. 
      Этот обработчик должен подключить этот поток к потребителю, например к элементу <a
        href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/video">video</a> 
        </li>

    <li>
      Вызывающий узел создаёт уникальный идентификатор, токен или нечто, что сможет идентифицировать вызов на сигнальном
      сервере, и обмениваться с принимающим узлом. Форма и содержимое идентификатора остаётся на усмотрение
      разработчика.
    </li>

    <li>
      Каждый узел подключается к согласованному сигнальному серверу, такому например как известный обоим
      WebSocket-сервер, для обмена сообщениями.
    </li>

    <li>
      Каждый узел сообщает сигнальному серверу, что хочет подключиться к одной и той же WebRTC-сессии (идентифицируемой
      токеном, определённым на шаге 4)
    </li>
  </ol>
  </P>

  <h3 id="five_three"> Перезапуск сессии ICE агент</h3>
  <p>
    Иногда, во время срока службы WebRTC сессии, сетевые условия изменяются. Один из пользователей, возможно, перейдёт
    от сотовой сети к сети WiFi или сеть может стать перегруженной. Например: когда это произойдёт, ICE агент может
    перезапустить сессию. Это процесс, с помощью которого сетевое соединение перезапустится и восстановится, точно таким
    же образом выполняется начальная установка сессии, за одним исключением того пока не установится новая сессия. Тогда
    сессия сменяется и переходит к новому сетевому соединению, а старое соединение закрывается.
  </p>
  <p>
    Есть два уровня перезапуска сессии: полная перезагрузка сессии вызывает все мультимедийные потоки в сеансе и должны
    быть пересмотрены. Частичная перезагрузка сессии позволяет агенту сессии перезапустить конкретный медиапоток вместо
    того, чтобы перезапускать все медиаданные.
  </p>
  <div style="clear:both; padding-bottom:0.25em"></div>


  <a href=# title="Back Up" class="topbutton"> ↑ Up </a>